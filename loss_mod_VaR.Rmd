---
title: "Loss Given Default/VaR"
author: "Daniel Bereket"
date: "3/15/2017"
output: html_document
---

# Loss given default

```{r}
library(tree)
library(randomForest)
library(splines)
library(dplyr)

# Set up loss training set
loss_train <- read.csv('training_set.csv')
loss_train <- loss_train[loss_train$isDefault==1,]

# Cleaning NA values for training set
loss_train <- loss_train[!is.na(loss_train$interestRate),]
loss_train <- loss_train[!is.na(loss_train$unemploymentRate),]
loss_train <- loss_train[!is.na(loss_train$hpiState),]
loss_train <- loss_train[!is.na(loss_train$tedSpread),]
loss_train <- loss_train[!is.na(loss_train$sandp500),]
loss_train <- loss_train[!is.na(loss_train$TermInMonths),]

df <- read.csv('SBA_cleaned_data.csv')
chg_vals <- select(df, GrossChargeOffAmount)
chg_vals$loanNum <- c(1:nrow(df))
loss_train <- left_join(loss_train, chg_vals, by="loanNum") # adding charge off values


# Set up loss validation set
loss_valid <- read.csv('validation_set.csv')
loss_valid <- loss_valid[loss_valid$isDefault==1,]
loss_valid <- left_join(loss_valid, chg_vals, by="loanNum") # adding charge off values

# Cleaning NA values for validation set
loss_valid <- loss_valid[!is.na(loss_valid$interestRate),]
loss_valid <- loss_valid[!is.na(loss_valid$unemploymentRate),]
loss_valid <- loss_valid[!is.na(loss_valid$hpiState),]
loss_valid <- loss_valid[!is.na(loss_valid$tedSpread),]
loss_valid <- loss_valid[!is.na(loss_valid$sandp500),]
loss_valid <- loss_valid[!is.na(loss_valid$TermInMonths),]

# Update training & validation set to have loss ratio
loss_train$LossRatio <- loss_train$GrossChargeOffAmount / loss_train$GrossApproval
loss_train$RatioLogit <- loss_train$LossRatio / (1 + loss_train$LossRatio)

loss_valid$LossRatio <- loss_valid$GrossChargeOffAmount / loss_valid$GrossApproval
loss_valid$RatioLogit <- loss_valid$LossRatio / (1 + loss_valid$LossRatio)


# Training loss model -- linear regression (threshold)
loss.lm <- lm(LossRatio~interestRate+unemploymentRate+log(hpiState)+tedSpread+sandp500+TermInMonths, data=loss_train,na.action=na.exclude)
summary(loss.lm)

lm.losspred <- predict(loss.lm, newdata=loss_valid)
lm.mse <- mean((lm.losspred-loss_valid$LossRatio)^2)
lm.mse

# Creating log hpi state column
loss_train$loghpi <- log(loss_train$hpiState)
loss_valid$loghpi <- log(loss_valid$hpiState)

# Training loss model -- bagging
bag.tree <- randomForest(LossRatio~interestRate+unemploymentRate+loghpi+tedSpread+sandp500+TermInMonths, data=loss_train, mtry=6, ntree=90)
summary(bag.tree)

bag.losspred <- predict(bag.tree, newdata=loss_valid, type="response")
bag.mse <- mean((bag.losspred-loss_valid$LossRatio)^2)
bag.mse


# Training loss model -- random forests
rf.tree <- randomForest(GrossChargeOffAmount~interestRate+unemploymentRate+loghpi+tedSpread+sandp500+TermInMonths, data=loss_train, mtry=2, ntree=90)
summary(bag.tree)

rf.losspred <- predict(bag.tree, newdata=loss_valid, type="response")
rf.mse <- mean((rf.losspred-loss_valid$LossRatio)^2)
rf.mse

# Training loss model -- regression spline
loss.spl <- lm(LossRatio~bs(interestRate,df=3)+bs(unemploymentRate,df=3)+bs(log(hpiState),df=3)+bs(tedSpread,df=3)+bs(sandp500,df=3)+bs(TermInMonths,df=3),data=loss_train)

spl.losspred <- predict(loss.spl,newdata=loss_valid)

spl.mse <- mean((spl.losspred-loss_valid$LossRatio)^2)
spl.mse


```

# VaR Calculation

```{r}
library(PerformanceAnalytics)

## ONE YEAR LOSSES

# Reading in test set
test500_set <- read.csv('test500_set.csv')

# TEMP: Sample default probabilities
def.probs <- runif(500,0,1)

# Monte Carlo values
def.unif <- runif(500,0,1)

# Matrix of default events
test.def <- ifelse(def.unif<def.probs, 1, 0)

# Test loss predictions -- using random forests
test.loss <- predict(rf.tree, newdata=test500_set)

# Losses
test.prob.loss <- test.loss * test500_set$GrossApproval * test.def

loss.matrix.1 <- matrix(nrow=500, ncol=500)
loss.var95.1 <- rep(0,500)
loss.avar95.1 <- rep(0,500)
loss.var99.1 <- rep(0,500)
loss.avar99.1 <- rep(0,500)

# BOOTSTRAP
for (i in 1:500) {
  
  for (j in 1:500) {
    # Creating bootstrapped sample
    curr.rows <- sample(c(1:500), replace=TRUE)
    curr.vals <- test500_set[curr.rows,]
    
    # Getting losses
    curr.prob.loss <- test.prob.loss[curr.rows,]
    
    # Calculating total loss, store it in matrix
    total.loss <- sum(curr.prob.loss)
    loss.matrix.1[i,j] <- total.loss
  }
  
  # Calculate VaR for both confidence levels
  curr.loss.sum <- loss.matrix.1[i,]
  curr.var <- quantile(curr.loss.sum, probs = seq(0.95, 0.99))
  
  loss.var95.1[i] <- curr.var[1]
  loss.var99.1[i] <- curr.var[2]
  
  # Calculate AVaR for both confidence levels
  loss.avar95.1[i] <- ES(curr.loss.sum, p=0.95, method="historical", clean="none", portfolio_method="single")
  
  loss.avar99.1[i] <- ES(curr.loss.sum, p=0.99, method="historical", clean="none", portfolio_method="single")
}

# Plot VaR & AVaR
pl.var95.1 <- hist(loss.var95.1, main = "VaR Frequency: 1-Year Loss", xlab = "VaR (95% level)")
abline(v=quantile(loss.var95.1,probs=seq(0.95)),col="red")

pl.var99.1 <- hist(loss.var99.1, main = "VaR Frequency: 1-Year Loss", xlab = "VaR (99% level)")
abline(v=quantile(loss.var99.1,probs=seq(0.99)),col="red")

pl.avar95.1 <- hist(loss.avar95.1, main = "AVaR Frequency: 1-Year Loss", xlab = "AVaR (95% level)")
abline(v=quantile(loss.avar95.1,probs=seq(0.95)),col="red")

pl.avar99.1 <- hist(loss.avar99.1, main = "AVaR Frequency: 1-Year Loss", xlab = "AVaR (99% level)")
abline(v=quantile(loss.avar99.1,probs=seq(0.99)),col="red")

# Tranches
lossvector.1 <- unlist(loss.marix.1)

maxloss.1 <- max(lossvector.1)
thresh5.1 <- 0.05*maxloss.1
thresh15.1 <- 0.15*maxloss.1

junior.tranche.1 <- ifelse(lossvector.1 > thresh5.1, min(c(100, (lossvector.1-thresh5.1)/thresh15.1)), 0)
senior.tranche.1 <- ifelse(lossvector.1 > thresh15.1, (lossvector.1-thresh15.1)/maxloss.1, 0)

junior.plot.1 <- plot(lossvector.1/maxloss.1, junior.tranche.1)
senior.plot.1 <- plot(lossvector.1/maxloss.1, senior.tranche.1)


## FIVE YEAR LOSSES

# TEMP: Sample default probabilities
def.probs <- runif(500,0,1)

# Monte Carlo values
def.unif <- runif(500,0,1)

# Matrix of default events
test.def <- ifelse(def.unif<def.probs, 1, 0)

# Losses (using same loss given default predictions as before)
test.prob.loss <- test.loss * test.def

loss.matrix.5 <- matrix(nrow=500, ncol=500)
loss.var95.5 <- rep(0,500)
loss.avar95.5 <- rep(0,500)
loss.var99.5 <- rep(0,500)
loss.avar99.5 <- rep(0,500)


# BOOTSTRAP
for (i in 1:500) {
  
  for (j in 1:500) {
    # Creating bootstrapped sample
    curr.rows <- sample(c(1:500), replace=TRUE)
    curr.vals <- test500_set[curr.rows,]
    
    # Getting losses
    curr.prob.loss <- test.prob.loss[curr.rows,]
    
    # Calculating total loss, store it in matrix
    total.loss <- sum(curr.prob.loss)
    loss.matrix.5[i,j] <- total.loss
  }
  
  # Calculate VaR for both confidence levels
  curr.loss.sum <- loss.matrix.5[i,]
  curr.var <- quantile(curr.loss.sum, probs = seq(0.95, 0.99))
  
  loss.var95.5[i] <- curr.var[1]
  loss.var99.5[i] <- curr.var[2]
  
  # Calculate AVaR for both confidence levels
  loss.avar95.5[i] <- ES(curr.loss.sum, p=0.95, method="historical", clean="none", portfolio_method="single")
  
  loss.avar99.5[i] <- ES(curr.loss.sum, p=0.99, method="historical", clean="none", portfolio_method="single")
}

# Plot VaR & AVaR
pl.var95.5 <- hist(loss.var95.5, main = "VaR Frequency: 5-Year Loss", xlab = "VaR (95% level)")
abline(v=quantile(loss.var95.5,probs=seq(0.95)),col="red")

pl.var99.5 <- hist(loss.var99.5, main = "VaR Frequency: 5-Year Loss", xlab = "VaR (99% level)")
abline(v=quantile(loss.var99.5,probs=seq(0.99)),col="red")

pl.avar95.5 <- hist(loss.avar95.5, main = "AVaR Frequency: 5-Year Loss", xlab = "AVaR (95% level)")
abline(v=quantile(loss.avar95.5,probs=seq(0.95)),col="red")

pl.avar99.5 <- hist(loss.avar99.5, main = "AVaR Frequency: 5-Year Loss", xlab = "AVaR (99% level)")
abline(v=quantile(loss.avar99.5,probs=seq(0.99)),col="red")

# Tranches
lossvector.5 <- unlist(loss.marix.5)

maxloss.5 <- max(lossvector.5)
thresh5.5 <- 0.05*maxloss.5
thresh15.5 <- 0.15*maxloss.5

junior.tranche.5 <- ifelse(lossvector.5 > thresh5.5, min(c(100, (lossvector.5-thresh5.5)/thresh15.5)), 0)
senior.tranche.5 <- ifelse(lossvector.5 > thresh15.5, (lossvector.5-thresh15.5)/maxloss.5, 0)

junior.plot.5 <- plot(lossvector.5/maxloss.5, junior.tranche.5)
senior.plot.5 <- plot(lossvector.5/maxloss.5, senior.tranche.5)
```

