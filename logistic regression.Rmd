---
title: "logistic regression"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Read the training, validation and test data via this code

```{r}
library(dplyr)
library(ROCR)
library(glmnet)

## LOGISTIC REGRESSION
## LOGISTIC REGRESSION

# Constructing Model
set.seed(1)
training_set = read.csv("training_set.csv")
valid_set = read.csv("validation_set.csv")
test500_set = read.csv("test500_full.csv")
test_set = read.csv("test500_set.csv")

training_set$Naics2digits <- as.factor(training_set$Naics2digits)
valid_set$Naics2digits <- as.factor(valid_set$Naics2digits)
test_set$Naics2digits <- as.factor(test_set$Naics2digits)

```


```{r}
# Lasso

lasso_training = training_set

lasso_training[is.na(lasso_training)] <- 0

training_set$Naics2digits = as.factor(training_set$Naics2digits)
x.lasso = model.matrix(training_set$isDefault~log(GrossApproval)+hpiState+log(ThirdPartyDollars)+
                         unemploymentRate+interestRate+sandp500+tedSpread+
                         NotSameState+BusinessType+DeliveryMethod+
                         TermInMonths+ApprovalFiscalYear+BorrState+
                         CDC_State+Naics2digits+gdpIndustry, data = training_set)[,-1]
lasso_training = filter(lasso_training, !is.na(unemploymentRate))
lasso.mod = glmnet(x.lasso, as.factor(lasso_training$isDefault), alpha = 1,family = "binomial")
cv.out = cv.glmnet(x.lasso, lasso_training$isDefault, alpha = 1,family = "binomial")
plot(cv.out)
cv.out
plot(lasso.mod,xvar = "lambda")
# interestRate, ApprovalFiscalYear
predict(cv.out, s = cv.out$lambda.1se, type = "coefficients")
predict(cv.out, s = cv.out$lambda.min, type = "coefficients")

# Elastic Net

# Variable Importance Plot

test_filter <- filter(test_set,BorrState != "VI")
test_filter <- droplevels(test_filter)
test_filter$isDefault <- as.factor(test_filter$isDefault)

library(randomForest)
rf.test =randomForest(isDefault???GrossApproval+hpiState+ThirdPartyDollars+
                         unemploymentRate+interestRate+sandp500+tedSpread+
                         NotSameState+BusinessType+DeliveryMethod+
                         TermInMonths+ApprovalFiscalYear+BorrState+
                         CDC_State+Naics2digits+gdpIndustry
                      ,data=test_filter,mtry = 4, importance = TRUE)
importance(rf.test)
levels(training_set$BorrState)
varImpPlot(rf.test,type=2)

```

GrossApproval+hpiState+unemploymentRate+interestRate+
                            sandp500+NotSameState+SBLR+
                            BusinessType+DeliveryMethod+
                            TermInMonths+ApprovalFiscalYear+
                            BorrState+++Naics2digits+gdpIndustry

```{r}
# Model Logistic with correct variables and time varying model
log_reg=glm(isDefault ~ interestRate+ApprovalFiscalYear+gdpIndustry+
              log(GrossApproval)+hpiState+unemploymentRate+
              sandp500+NotSameState+Naics2digits
            ,family="binomial",data=training_set)

summary(log_reg)
#predict of valid_set w/o splitting time periods
pred_log_reg=predict(log_reg,valid_set,type="response")
log_reg_predict_values = c(rep(0,nrow(valid_set)))
log_reg_predict_values[pred_log_reg>0.07] <-1 
table(log_reg_predict_values, valid_set$isDefault)

# pred_log_reg - Conditional Prob of Default
# valid_set = validation set

loan_indices <- as.data.frame(unique(valid_set$loanNum))
loan_indices$start <- 1
loan_indices$stop <- 1
colnames(loan_indices) <- c("loan_no","start","stop")
l = 1
counter = 1

# find start and stop for each loan
for(i in 1:nrow(valid_set)){
  if(valid_set$endIndicator[i]==1){
    loan_indices$stop[l]=i
    l=l+1
    if(l<=nrow(loan_indices)){
    loan_indices$start[l]=i+1
    }
  }
}

pred_test <- rep(0,length(pred_log_reg))

for(i in 1:nrow(loan_indices))
{
  a = loan_indices$start[i]
  b = loan_indices$stop[i]
  for(j in a:b){
    if(j==a){
      pred_test[a]=pred_log_reg[a]
    }
    else{
      for(k in a:j){
        counter = counter*(1-pred_log_reg[k])
      }
       pred_test[j]=1-counter
    }
    counter = 1
  }
}

pred_test_val <- rep(0,length(pred_log_reg))
pred_test_val[pred_test>0.08] <-1 
table(pred_test_val,valid_set$isDefault)

# for loop over start and stop for each loan

## if i = 1 => Prob of default is just the cond. prob
## if i>1
### for loop from 1 to i-1
#### multiply with survival
### multiply with default in i


#ROC Curve
#does not work if no loans defaulted. Only works when there are two classes.
pred1 = prediction(pred_test, valid_set$isDefault)
perf1 = performance(pred1, "tpr", "fpr")
plot(perf1)
auc1 <- performance(pred1,measure = "auc")
auc1 <- auc1@y.values[[1]]
auc1
```